# makeheap: алгоритм и доказательство O(N)

## Алгоритм makeheap(arr)

Пусть `arr` — произвольный массив длины `n`, в котором мы хотим получить **min-heap**.

Интерпретируем массив как полное бинарное дерево:

- корень — `arr[0]`,
- левый сын узла `i` — `arr[2*i + 1]`,
- правый сын узла `i` — `arr[2*i + 2]`.

Инвариант min-heap:

> значение в узле не больше значений его детей (если дети существуют).

Алгоритм:

1. Все **листья** уже являются min-heap (у них нет детей, инвариант выполнен).
2. Считаем, что индексы листьев начинаются с `n // 2`.  
   Значит, последний *внутренний* узел имеет индекс `last_internal = n // 2 - 1`.
3. Обходим узлы снизу вверх:

   ```text
   for i = n//2 - 1, n//2 - 2, ..., 0:
       sift-down(i)
   ```

4. `sift-down(i)`:

   - пока у `i` есть хотя бы один ребёнок:
     - находим индекс минимального ребёнка (из двух)`j`,
     - если `arr[i] <= arr[j]`, heap-инвариант выполнен, выходим,
     - иначе меняем `arr[i]` и `arr[j]` местами и продолжаем с `i = j`.

После такого прохода по всем внутренним узлам получаем корректный min-heap во всём массиве (мы убедились,
что для всех вершин сохраняется инвариант).

---

## Доказательство сложности O(N)

Обозначения:

- высота дерева — `H ≈ O(log N)` (полное бинарное дерево),
- **высота узла** — расстояние от узла до *самого глубокого листа* в его поддереве:
  - у листа высота `0`,
  - у его родителя — `1`, и т.д.

Несколько наблюдений:

1. Узел высоты `h` при `sift-down` может опуститься **не более чем на h уровней**.
   Значит, стоимость одного `sift-down` для узла высоты `h` — `O(h)`.

2. Сколько узлов высоты `h` может быть в полном бинарном дереве?  
   В худшем случае их не больше, чем `N / 2^{h}`, так как все такие поддеревья не могут пересекаться (у каждой
   вершины один предок, высота любой вершины в поддереве будет меньше, чем h). Следовательно, в одном поддереве `2^{h}` вершин, и дальше
   делим число вершин на число вершин в поддереве.

Итого, полная стоимость алгоритма — сумма по всем узлам:

```text
T(N) ≤ Σ_{h=0}^{H} (кол-во узлов высоты h) * O(h)
     ≤ Σ_{h=0}^{H} (N / 2^{h}) * O(h)
     =  N * Σ_{h=0}^{H} O(h / 2^{h})
```

Рассмотрим ряд:

```text
S = Σ_{h=0}^{∞} h / 2^{h}
```

Он **сходится** (это стандартный степенной ряд), и сходится к сумме 2.:

То есть:

```text
Σ_{h=0}^{H} h / 2^{h}  = O(1)
```

Подставляем обратно:

```text
T(N) ≤ N * O(1) = O(N)
```

Таким образом, алгоритм работает за **линейное время O(N)**, несмотря на то, что отдельное просеивание вниз может занимать `O(log N)`.  

