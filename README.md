# HSE Algorithms in Python

## Структура

- hw1/, hw2/, ... — папки с домашками
- hwN/src/task_i.py — решение задачи i
- hwN/tests/test_task_i.py — тесты к задаче i

## Запуск тестов

Пример для hw1:

1. перейти в папку домашки:

    cd hw1

2. запустить все тесты:

    PYTHONPATH=. pytest

3. запустить тесты только для одной задачи:

    PYTHONPATH=. pytest tests/test_task_1.py

4. запустить тесты одной задачи с подробным выводом (имена тестов и статус):

    PYTHONPATH=. pytest -v tests/test_task_1.py
    или
    PYTHONPATH=. pytest -vv tests/test_task_1.py - еще более удобный вывод

5. запустить один конкретный тест и не скрывать print (на примере HW7):

    cd hw7  
    PYTHONPATH=. pytest -s tests/test_task_1.py::test_large_equal_array_mergesort_faster


## Соответствие задач файлам

HW1  
- task_1 — Palindrome  
- task_2 — Sum (максимальная сумма, кратная 2)  
- task_3 — Prime (количество простых < N)

HW2  
- task_1 — Stack vs queue (стек и очередь на списках)  
- task_2 — Validate (последовательности операций стека)  
- task_3 — Merge lists (слияние двух отсортированных списков)

HW3  
- task_1 — Two sum (индексы пары по сумме k)  
- task_2 — Anagrams (группировка анаграмм)  
- task_3 — Hash table (своя хеш-таблица на list)

HW4  
- task_1 — Traversal (все обходы BST)  
- task_2 — Validate BST (проверка, что дерево — BST)  
- task_3 — Balanced binary tree (проверка балансировки по высоте)

HW5  
- task_1 — Tracer (декоратор для вывода стека рекурсии)  
- task_2 — Permutations (перестановки массива + tracer)  
- task_3 — AVL (самобалансирующееся BST)

HW6
- task_1 — Compare (mergesort, quicksort, декоратор времени)


## Замечания

Во всех тестах реалилзована проверка на небольших наборах, а так же, где это возможно, 
реализована генерация большого числа случайных данных и сравнение с гарантированно правильными решением.
Например, в случае сортировки, или генерации перестановок, у нас есть библиотечные методы.

Однако в некоторых задачах
не существует какого-то простого гарантированно работающего решения, в этих задачах реализован только набор
краевых случаев и небольших тестов. 


- В HW4 (BST) используется инвариант:

  - слева: значение строго меньше (`<`) значения в узле;  
  - справа: значение больше либо равно (`>=`) значению в узле.

- В HW5 (AVL) дерево хранит только **уникальные** значения:

  - повторная вставка того же значения игнорируется;  
  - так проще сохранять корректный инвариант BST при поворотах (с дубликатами
    инвариант вида «все дубликаты только справа» при вращениях не сохраняется).

- В HW6 (Compare: mergesort и quicksort) в тестах реализованы:

  - большой случайный массив, на котором время работы mergesort и quicksort
    приблизительно сопоставимо;
  - большой массив из одинаковых элементов, на котором mergesort заметно
    быстрее quicksort.
  - в обоих тестах реализовано сравнение с библиотечной сортировкой sorted в Python
  - тесты реализованы и для рекурсивного случая, и для итеративного

- В HW8 в тестах реализована работа с графами не только при помощи ручных тестов,
но и при помощи библиотеки networkx. Ее необходимо установить для работы тестов: pip install networkx.